jvm stack frame存放局部变量，操作栈，动态连接，方法出口等信息，与线程生命周期一致,局部变量表再编译期确定大小，不会改变
方法区(也叫非堆)存放类信息，常量，静态变量，jit后的代码的代码等数据，这块垃圾回收主要是常量池的回收也对类的卸载，回收效果一般不太好，
hotspot当成永久代管理方法区，1.8移除，改成了一个叫元空间的一个东西(也就是说从堆内存移动到了物理内存)，与之前的永久代的区别就是这个元空间是受物理内存的限制，不会再抛出OME了.
java可以利用直接内存，虽然不再jvm规范内，但是可以缓冲区nio去操作，这样避免了jvm内的复制过程，有时候可以明显提升性能。
Java内存模型是一个规范，主要规定了线程件的可见性和共享变量的同步，也就是线程私有变量和主内存的一个交互逻辑规范。
堆，方法区，执行引擎和本地接口是线程共享的，栈和程序计数器是线程私有的。
多线程环境下栈创建过多也可以OME，如果栈太深了也可以StackOutflowError
JMM只保证基本的读取和直接(int a = 1)赋值是原子操作
原子性，可见性，有序性
指令重排序单个线程不会影响，但是多个线程
volatile和synchronize都可以保证原子性，volatile是改了之后直接刷新到主存，synchronize是在释放锁之前把所有的改动写入到主存
jvm内存结构，内存模型，对象模型 区分
jvm就是各个部分的一个规范，内存模型就是多线程之间的共享，对象模型就是具体格式
现在都是分代垃圾收集算法，新生代Minior GC非常频繁，回收快。老年代Major GC,速度慢，频率低。
优先年轻代，大对象和长期存活对象进入老年代，为了计算“长期”，会给每个对象一个年龄计数器。默认15(可以配置)次移动还存在就晋升老年代。
判断对象是否死亡，引用计数法效率高，简单，但是循环引用比较麻烦。主要还是靠可达性分析。
引用类型：强引用 内存不够就抛出OME。  软引用 平时不回收，当内存空间不足就回收。  弱引用  回收线程扫描弱引用就回收（优先级比较低，所以不一定会回收），虚引用。
软引用比其他两个更弱的引用更有价值，主要避免OME
扫描到了被标记而已，还可以执行finalize方法，执行完了再检查一次是否可达，如果不可达才可以真的回收。
常量池也是进行引用查看，没有引用就直接回收了。
对于类的标记，实例都回收、该ClassLoader被回收，Class引用没引用，就可以(不是必然)回收。
算法：标记-清除（效率，碎片），复制算法（解决前一个问题，年轻代），标记-整理（老年代），分代收集
eden : survivor = 默认 8 : 1 : 1
老年代对空间比较敏感，年轻代对时间比较敏感
CMS是老年代比较适合的算法是并发标记清除的意思，第一步是初始标记，并发标记，重新标（并发标记期间产生变化，比并发标记短很多），并发清除。初始标记和重新标记仍然需要STW，采用了分周期隔离，只把需要STW的周期才STW, 并发收集，停顿低。
G1就是把堆分成很多region，其中利用卡表等技术优化避免全堆扫描。可预测停顿。
相同类加载的顺序在不同的环境不一致，可能是不同的环境磁盘的排列顺序问题。
jit 机制？

垃圾收集器：
Serial单线程效率高但是STW体验不好.
ParNew就是Serial的多线程版本（并发执行，效率更高，但是也会STW），
Parallel Scavenge与ParNew类似，但更关注吞吐量。
Serial old为Serial的老年代版本。
Parallel Old为Parallel Scavenge的老年代版本。
CMS为最短暂停顿时间为目标的GC(第一款并发收集，与用户线程同时执行,初始标题，并发标记，重新标记，并发清除四个阶段)优点并发收集，低停顿，但是对CPU资源敏感，无法处理浮动垃圾，会产生空间碎片。
G1 高性能多核大内存的机器，最大限度降低STW, 特点：并行并发，分代收集，空间整合，可预测停顿。不产生碎片。

FullGC就是针对各个代要分配的空间不够的情况全面回收。
Minor GC 为新生代（eden和两个survivor）的回收。Eden区满的时候触发。存活的移动到survivor，from -> to (空的)
如果Minor GC回收发现剩下eden和survivor加起来大于survivor就会提前移动到老年代，这样多了之后老年代FullGC都不够溢出就内存泄漏了。
JVM避免Minor GC扫描全堆，因为新生代可能引用老年代对象，要识别GC roots，就扫描到老年代了，可以采用卡表的技术，把老年代按空间大小分成多个卡片，如果有新生代引用的，就把卡表标记为脏卡，到时候寻找GC roots就可以只扫描脏卡了，不需要进行全堆扫描。

jvm的类加载和连接与初始化都是在运行期间完成的，这种策略会增加编程的灵活性，但是会损失一点点性能。
类的生命周期：加载、验证、准备、解析、初始化、使用、卸载。其中解析可以在初始化之后进行，因为要实现动态绑定。
触发加载的唯一五种方式。1. 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果累没有进行初始化，则要先触发初始化；
    2. 使用java.lang.reflect包中的方法对类进行反射调用的时候；
    3. 初始化类时，若发现其父类还没有初始化，则先触发父类的初始化；
    4. 虚拟机启动的时候，虚拟机会先初始化用户指定的包含main()方法的那个类
    5. 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

数组 new Object[]不会触发初始化。final 阶段的常量会在编译期就放常量池了，不会触发初始化。
类的初始化是类的各个成员赋初始值的过程。
准备是给static变量分配内存设置初始值(类型初始值)的阶段。final的话会池实话为定义值。
解析就是把符号引用转换成直接引用。
初始化是执行类构造<clinit>(注意区分实例构造器)static部分方法的过程。程序员定义的static代码。
类构造器先执行父类再执行子类，可以没有类构造器

最新的ZGC