hashMap为什么头插入链表? 设计者觉得后插入被查找的可能性更大。
初始长度16，自动或手动初始化，都是2的幂。
hash值取摸简单，但是效率很低，所以采用位运算。因为2的n次方-1，都是11111..所以都是依赖于输入的哈希值的尾巴，只要哈希函数均匀，就可以均匀。
HashTable在新的代码已经不推荐使用，ConcurrentHashMap更好.HashMap允许一个null为key
HashMap java8增加了红黑树的结构，桶查找算法复杂度O(n)降低到了O(logn) resize的优化。
hashMap线程不安全，put可能造成线程丢失被覆盖，get的时候遇到resize会造成线程不安全, 因为重新resize之后，可能形成循环链表.
HashMap 8之前都是头插入因为作者觉得后写入的值更先访问 wtf，8开始改用尾插法，因为这样能保持扩容后的相对链表的指向方向，避免循环链表
jdk7 使用segment,默认16个，jdk8摈弃了segment。而是node数组，链表超过8会转换为红黑树。
synchronizedMap
fail-safe(拷贝对象遍历) 与  fail-fast区别
hashtable的key不允许为null，因为早期觉得元素都要实现equals和hashCode方法，null肯定没有，但是hashMap会放到一个特殊的位置
ConcurrentHashMap put的时候会CAS尝试写入，失败就自旋，数量大会转换红黑树, 
红黑树的自平衡性比较好，让它高度很低
hashmap负载因子为什么是0.75
ConcurrentHashMap 1.7的segement需要两次hash, 优点就是降低了锁粒度
ConcurrentHashMap 1.8和HashMap基本一致了，不过采用了volatile和CAS来put, 长度大于某个值红黑树结构

treeSet的内部就是treeMap实现，使用的红黑树来实现的.要求key能排序.
冒泡排序就是两两连续比较
选择排序，遍历一遍找到最小，第二遍找第二小...以此类推
插入排序，拿第一个放到开头，第n个元素依次来找已经排序好的数组进行选择位置插入.
希尔排序，是分成若干个数组进行插入排序。

treeMap底层实现的红黑树
AVL树是带了平衡的二叉搜索树

二叉搜索树，在极端情况会退化成链表，查询性能差，所以引入了平衡树，但是平衡树在修改的时候很容易就被破坏结构，所以引入了红黑树，这样改变也能保证logn的复杂度。


synchronized降低获取锁的难度。 
synchronized几种状态，锁只有升级，不会降级，偏向锁(如果是存在竞争会释放并升级锁，会有消耗)就是单个线程进入临界区，轻量级锁（会自旋，如果一直得不到可能消耗cpu）就是多个线程交替进入临界区，重量级锁(不自旋了，直接阻塞)是多个线程同时进入临界区。
无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。也就是CAS（CAS是基于无锁机制实现的）。
偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。
是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。
shutdown是不接收新的执行任务，正在执行等待执行结束，shutdownNow是拒绝新的任务，并且正在执行的也结束。
ThreadPoolExecutor有个allowCoreThreadTimeOut可以允许核心线程被回收
去阻塞队列拿任务超过设置的时间还没拿到就超时线程被回收
SynchronousQueue是无缓冲的队列，必须要消费一个才能放入一个，有公平和非公平两种模式.LinkedBlockingQueue可缓冲的指定大小的队列，两个独立的锁并发写入和读取性能更高，但是GC会产生node开销会大一些。ArrayListBlockingQueue也是有界队列


valatile关键字，解决缓存一致性 总线锁（阻塞其他cpu效率太低）->缓存缩小粒度->MESI(修改、独家、共享、无效)会同步通知其他核失效缓存，嗅探CAS不断循环，无效导致总线带宽达到峰值， 性能太低->Store Buffers不用同步等待，写回主存的时候确认就好了。
重排序的原因就是修改了cpu缓存刷新到主存的时间是不确定的，导致后更改的值先刷到主存，在其他线程来看就是乱序了。
内存屏障就是让数据之前的数据对后面的执行都更先刷到主存，对其他线程来说是顺序的。保证不被重排序影响。
非常深入的 https://www.toutiao.com/i6859927959499702792/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1597214361&app=news_article&utm_source=weixin&utm_medium=toutiao_ios&use_new_style=1&req_id=202008121439210100260760220A00FBDC&group_id=6859927959499702792
https://juejin.im/post/6844904149536997384


如果只是运行java程序程序，那安装jre就好了，需要编译才需要jdk , 但是如果是有jsp,那还是需要jdk,因为要编译jsp为Java servlet。

Java反射慢，根本上是没法对反射代码做优化。